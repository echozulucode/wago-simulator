# WAGO 750 I/O System Simulation Design

The WAGO I/O System 750/753 is a modular, fieldbus‐independent remote I/O platform supporting hundreds of I/O modules (over 500 total devices)[[1]](https://www.wago.com/us/discover-io-systems/750#:~:text=Boasting%20more%20than%20500%20I%2FO,both%20hardware%20and%20system%20expenses). It consists of a **fieldbus coupler (head unit)** and pluggable I/O cards (e.g. digital or analog channels) that mount on a DIN rail. For example, an 8-channel digital input card (e.g. 750-1425) provides eight binary sensor inputs with built-in fault detection (open/short)[[2]](https://docs.rs-online.com/dcf2/A700000010764080.pdf#:~:text=Up%20to%20six%20PTC%20thermistors,in%20the%20input%20process%20im%02age), while analog cards (e.g. Pt100/RTD or 4–20 mA input modules) provide 16-bit data and status bits per channel[[3]](https://www.scribd.com/document/862834561/Wago-750-455-Manual#:~:text=Process%20Image)[[4]](https://www.instrumentsindustry.com/18685.html#:~:text=Bit%20width%202%20x%2016,bits%20data). A typical rack might include digital input (DI), digital output (DO), RTD (Pt100) input, and standard analog input modules. For the simulator, we will **predefine common card types** (like 8 DI, 8 DO, RTD, 4–20 mA AI) in the configuration but allow the user to add new types later. Each card type is identified by its WAGO module number (e.g. “750-1425”, “750-460”, “750-455”), and the config should list slots/modules by these IDs. A factory/builder pattern can then instantiate the correct card object for each module ID: for example, a factory method reads the module ID from the config and returns a new instance of the corresponding DI or AI class[[5]](https://refactoring.guru/design-patterns/factory-method#:~:text=The%20Factory%20Method%20pattern%20suggests,often%20referred%20to%20as%20products). This decouples creation from usage so new module classes can be added without changing core logic.

![](data:image/png;base64...)
*Figure: A WAGO 750-series I/O rack. The leftmost unit is a fieldbus coupler (with LEDs for status), followed by I/O cards (in gray) with pluggable jumpers and wiring.*

## Module Configuration and Factory Setup

* **Predefined Card Types:** List common WAGO modules in the config by their item number (e.g. 750-1425, 750-455, etc.) so the simulator knows each slot’s function. This allows easy expansion by adding new IDs later.
* **Factory/Builder Pattern:** Use a Factory Method approach to create I/O card objects. For example, a ModuleFactory.create(module\_id) function returns the appropriate card instance. All card classes implement a common interface (e.g. read\_inputs()/write\_outputs()), so client code treats them uniformly[[5]](https://refactoring.guru/design-patterns/factory-method#:~:text=The%20Factory%20Method%20pattern%20suggests,often%20referred%20to%20as%20products). This lets us add new module types by simply extending the factory logic or subclassing, without modifying existing creation code.
* **Configuration Format:** Define racks and slots in a config file (JSON, XML, etc.) listing each module ID and its position. The simulator reads this at startup, invokes the factory to build the rack, and initializes each module’s process image (internal data area).

Using this pattern ensures **extensibility**. For example, if later we include a new analog output card, we just add its class and factory entry. The core simulator code just cycles through generic module interfaces, so tests/clients remain unchanged.

## Exact Hardware Replication

The goal is to **emulate WAGO hardware exactly** so the embedded controller cannot tell the difference. To achieve this, the simulator must mimic the fieldbus coupler and I/O module behavior and data formats. In WAGO’s design, the fieldbus coupler communicates with higher-level controllers (typically via Modbus TCP, EtherNet/IP, or similar) and with I/O cards via an internal backplane. The coupler presents the entire rack’s I/O data as a “process image” of discrete inputs/coils and holding/input registers. For example, the 750-455 analog input module digitizes 4–20 mA signals into 16-bit values plus status bits[[3]](https://www.scribd.com/document/862834561/Wago-750-455-Manual#:~:text=Process%20Image)[[6]](https://www.scribd.com/document/862834561/Wago-750-455-Manual#:~:text=For%20the%20standard%20module%20750,ranging%20from%200x0000%20to%200x7FFF); a Pt100/RTD module provides two 16-bit temperature values plus 8-bit status flags each[[4]](https://www.instrumentsindustry.com/18685.html#:~:text=Bit%20width%202%20x%2016,bits%20data). Digital input cards give raw bits and error flags[[2]](https://docs.rs-online.com/dcf2/A700000010764080.pdf#:~:text=Up%20to%20six%20PTC%20thermistors,in%20the%20input%20process%20im%02age). The simulator must populate these data words just as real hardware would.

To emulate the WAGO coupler (e.g. a 4th-gen Modbus TCP coupler like the 750-362), we will run a server that implements the same protocol. For example, WAGO’s 750-362 coupler “connects the digital, analog and specialty modules of the WAGO-I/O-System via ETHERNET” using Modbus TCP/UDP[[7]](https://www.tsisolutions.us/itemdetail/750-362?srsltid=AfmBOoru0Lw4Hc-HDoJ9pBc9mgirBYZ7ix1ozX_9IgbLKGn2cFZuD3Go#:~:text=4th%20Generation%20The%20Modbus%20TCP,System%20via%20ETHERNET). Thus our simulator should listen as a Modbus/TCP slave (server) at the same port, with each WAGO module’s data mapped into consecutive registers. We can use libraries like **pymodbus** or **pyModbusTCP**: these allow Python code to act as a Modbus server (a “slave” device) that holds registers and coil states. In fact, as Jonas Neubert notes, one can “use pymodbus to make your Python code act as server (or ‘slave’) and have the PLC read and write variables on your laptop/server/etc.”[[8]](https://blog.jonasneubert.com/2019/11/02/using-pymodbus-to-communicate-with-a-plc/#:~:text=For%20the%20sake%20of%20completeness%2C,the%20PLC%20read%20and%20write). We will configure the register map so that reading/writing registers mimics the coupler’s process image (respecting WAGO’s addressing and data order). For example, analog inputs might occupy consecutive 16-bit registers (one per channel), with the low and high bytes ordered as WAGO expects[[3]](https://www.scribd.com/document/862834561/Wago-750-455-Manual#:~:text=Process%20Image).

**Data validity and errors:** The simulator should also mimic error flags. WAGO modules flag sensor faults in status bits[[2]](https://docs.rs-online.com/dcf2/A700000010764080.pdf#:~:text=Up%20to%20six%20PTC%20thermistors,in%20the%20input%20process%20im%02age)[[3]](https://www.scribd.com/document/862834561/Wago-750-455-Manual#:~:text=Process%20Image). We can inject errors in scenario scripts (see below) or when simulating fault conditions. For example, on an open-circuit input we set the status bits as WAGO defines. This lets the client’s logic that checks error bits operate normally.

## Scenario Scripting and Operation Modes

To **drive simulations**, we allow external scripts or scenario files to inject inputs and control behavior. We will support loading a scenario (e.g. a Python or Lua script, or JSON scenario file) at runtime. Each scenario can describe input changes over time or trigger faults. The server can call into the script on a timer or event, updating module values in the process image. The framework should allow one to **select a scenario** when launching the simulator, so testers can easily switch tests.

We will design the system for both **GUI and headless** operation. In GUI mode, a desktop application (e.g. using a toolkit like Qt or Tkinter) can display racks and I/O states, let the user toggle bits manually, and load scenarios interactively. For automated testing or CI, a **headless mode** should run without display, suitable for command-line control or integration into test harnesses. In headless mode we might accept configuration via command-line flags or a REST API. For example, the simulator could host a simple HTTP server with endpoints to query or override I/O values, pause the simulation, or switch scenarios. This REST interface would allow scripts or other tools (including possibly the embedded client itself) to reconfigure the simulation on the fly.

Regardless of mode, the underlying data and protocol handling is shared. The GUI is merely a front end to the same core “server” logic. This separation ensures consistency: tests run in headless mode behave identically to what the GUI would generate.

## Communication Protocol and Multi-Rack Support

Our embedded client devices expect to communicate with one or more WAGO racks on a network (likely via Modbus/TCP or another industrial protocol). We must support **multiple rack simulations** if required: e.g. spin up one server instance per rack (on different ports or IP addresses), so the client can connect to each independently. Each rack’s configuration (modules, mapping) is separate.

During normal operation, the simulated coupler will respond to Modbus queries exactly as a real WAGO would. We should implement common Modbus function codes: reading coils (for discrete inputs), reading holding/input registers (for analog values and status), and writing coils/registers (for outputs and configuration, if the coupler supports it). The WAGO 750-315/300 RTU coupler manual even notes that “Write access to output data is possible starting from MODBUS address 0x0000… an offset of 0x0200 must be added to the MODBUS address for read access to output data”[[9]](https://docs.rs-online.com/b5b0/A700000010039833.pdf#:~:text=Thus%2C%20input%20process%20image%20has,of%20an%20Input%20Process%20Image). We may need to handle any such offsets or quirks so that addresses match expectations.

For **communication loss and reconnect**, the simulator must handle network disconnects gracefully. If the client loses connection (e.g. the network cable is unplugged or the client reboots), the simulator should continue running and allow the client to reconnect later. Internally, the simulator can choose how to handle I/O state on interruption. By default, we should mimic WAGO behavior: if the “fieldbus” to the master (i.e. our simulator-to-client link) is lost, WAGO forces all outputs to a safe state (often zero). The manual states that “During a loss of fieldbus, the fieldbus coupler switches the output signal of the I/O modules to a value of ‘0’”[[10]](https://docs.rs-online.com/b5b0/A700000010039833.pdf#:~:text=During%20a%20loss%20of%20fieldbus%2C,bus%20error%20has%20occurred%20when). We will implement a similar “safety on loss” option: if no Modbus queries arrive for a configured timeout, the simulator can optionally drive all digital outputs low (or analog outputs to 0). This should be configurable per project (some tests may require holding last values instead). When the client reconnects, normal operation resumes.

We also handle **loss of power or internal bus** in simulation: if scripted in a scenario, we can simulate “power down” by cutting off I/O updates. On such events, modules should again default outputs to 0 (mimicking an actual fieldbus coupler’s behavior[[11]](https://docs.rs-online.com/b5b0/A700000010039833.pdf#:~:text=The%20fieldbus%20coupler%20determines%20that,fieldbus%20can%20be%20caused%20by)[[10]](https://docs.rs-online.com/b5b0/A700000010039833.pdf#:~:text=During%20a%20loss%20of%20fieldbus%2C,bus%20error%20has%20occurred%20when)). The GUI could show LEDs blinking, and the REST API could report the error status. This gives the client code a realistic environment to test fault handling.

## Summary

In summary, we will build a server-based emulator that exactly mimics the WAGO 750/753 I/O hardware interface. The simulator will read a rack configuration (by module numbers), use a factory pattern to instantiate module objects, and run a Modbus/TCP (or other protocol) server to exchange the process image with the embedded client. External scripts/scenarios can drive input values, and both a GUI and headless interface are supported. Careful attention to WAGO’s data formats and behavior (including loss-of-comm handling[[10]](https://docs.rs-online.com/b5b0/A700000010039833.pdf#:~:text=During%20a%20loss%20of%20fieldbus%2C,bus%20error%20has%20occurred%20when)) ensures high fidelity. This design allows the embedded developers to test their WAGO-connected code extensively without actual hardware, while preserving the ability to expand modules and customize scenarios.

**References:** Official WAGO I/O 750 documentation and data sheets were used to determine module data formats[[2]](https://docs.rs-online.com/dcf2/A700000010764080.pdf#:~:text=Up%20to%20six%20PTC%20thermistors,in%20the%20input%20process%20im%02age)[[3]](https://www.scribd.com/document/862834561/Wago-750-455-Manual#:~:text=Process%20Image). The factory design pattern is recommended to decouple module creation[[5]](https://refactoring.guru/design-patterns/factory-method#:~:text=The%20Factory%20Method%20pattern%20suggests,often%20referred%20to%20as%20products). Python’s pymodbus toolkit has been shown to effectively emulate a PLC’s Modbus server interface[[8]](https://blog.jonasneubert.com/2019/11/02/using-pymodbus-to-communicate-with-a-plc/#:~:text=For%20the%20sake%20of%20completeness%2C,the%20PLC%20read%20and%20write). WAGO’s Modbus/TCP coupler specifications guide the register mapping[[7]](https://www.tsisolutions.us/itemdetail/750-362?srsltid=AfmBOoru0Lw4Hc-HDoJ9pBc9mgirBYZ7ix1ozX_9IgbLKGn2cFZuD3Go#:~:text=4th%20Generation%20The%20Modbus%20TCP,System%20via%20ETHERNET), and their manuals describe output behavior on communication loss[[10]](https://docs.rs-online.com/b5b0/A700000010039833.pdf#:~:text=During%20a%20loss%20of%20fieldbus%2C,bus%20error%20has%20occurred%20when). These ensure the simulator replicates the real hardware accurately.

[[1]](https://www.wago.com/us/discover-io-systems/750#:~:text=Boasting%20more%20than%20500%20I%2FO,both%20hardware%20and%20system%20expenses) IP20 I/O System 750 – the Remote I/O System | WAGO USA

<https://www.wago.com/us/discover-io-systems/750>

[[2]](https://docs.rs-online.com/dcf2/A700000010764080.pdf#:~:text=Up%20to%20six%20PTC%20thermistors,in%20the%20input%20process%20im%02age) 750-1425\_EN

<https://docs.rs-online.com/dcf2/A700000010764080.pdf>

[[3]](https://www.scribd.com/document/862834561/Wago-750-455-Manual#:~:text=Process%20Image) [[6]](https://www.scribd.com/document/862834561/Wago-750-455-Manual#:~:text=For%20the%20standard%20module%20750,ranging%20from%200x0000%20to%200x7FFF) Wago 750-455 Manual | PDF | Electrostatic Discharge | Computer Engineering

<https://www.scribd.com/document/862834561/Wago-750-455-Manual>

[[4]](https://www.instrumentsindustry.com/18685.html#:~:text=Bit%20width%202%20x%2016,bits%20data) Wago 750-461 753-461 2-Channel Analog Input Modules for RTDs 750-461 753-461 I/O Systems Modules In Stock | HKXYTECH

<https://www.instrumentsindustry.com/18685.html>

[[5]](https://refactoring.guru/design-patterns/factory-method#:~:text=The%20Factory%20Method%20pattern%20suggests,often%20referred%20to%20as%20products) Factory Method

<https://refactoring.guru/design-patterns/factory-method>

[[7]](https://www.tsisolutions.us/itemdetail/750-362?srsltid=AfmBOoru0Lw4Hc-HDoJ9pBc9mgirBYZ7ix1ozX_9IgbLKGn2cFZuD3Go#:~:text=4th%20Generation%20The%20Modbus%20TCP,System%20via%20ETHERNET) 750-362 Wago Fieldbus Coupler Modbus Tcp

<https://www.tsisolutions.us/itemdetail/750-362?srsltid=AfmBOoru0Lw4Hc-HDoJ9pBc9mgirBYZ7ix1ozX_9IgbLKGn2cFZuD3Go>

[[8]](https://blog.jonasneubert.com/2019/11/02/using-pymodbus-to-communicate-with-a-plc/#:~:text=For%20the%20sake%20of%20completeness%2C,the%20PLC%20read%20and%20write) Using pymodbus to communicate with a PLC

<https://blog.jonasneubert.com/2019/11/02/using-pymodbus-to-communicate-with-a-plc/>

[[9]](https://docs.rs-online.com/b5b0/A700000010039833.pdf#:~:text=Thus%2C%20input%20process%20image%20has,of%20an%20Input%20Process%20Image) [[10]](https://docs.rs-online.com/b5b0/A700000010039833.pdf#:~:text=During%20a%20loss%20of%20fieldbus%2C,bus%20error%20has%20occurred%20when) [[11]](https://docs.rs-online.com/b5b0/A700000010039833.pdf#:~:text=The%20fieldbus%20coupler%20determines%20that,fieldbus%20can%20be%20caused%20by) Handbuch 750-315

<https://docs.rs-online.com/b5b0/A700000010039833.pdf>